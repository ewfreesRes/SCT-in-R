[
["index.html", "A Guide to Writing Submission Correctness Tests for Datacamp using R Preface", " A Guide to Writing Submission Correctness Tests for Datacamp using R Jake W. Thornton Preface Date: 16 April 2019 About Submission Correctness Tests As businesses continue to collect greater amounts of data, it becomes important for people to develop the technical skills necessary to analyze the data, and report back to the company. One company, DataCamp, offers a solution that can be used to teach programming skills in R and Python. To do this, content creators imagine and design problems that need to be solved using a specific series of coded inputs to help teach. These problems each have solutions that enable the computer to check and see if the learner’s input correctly matches the solution input. In DataCamp, the code used to check for correctness are solution correctness tests, or SCTs for short. In this short tutorial, you will learn how to write a wide variety of SCTs using R. The Basics of SCT’s The basics of writing a submission correctness test consist of an initializing function, a “chain” function, and then varying calls of “check” functions. The initializing function has the form: ex() while the “chain” function has the form: %&gt;% Combining the initial function and a single call of the chain function is the beginning of all the SCTs that you can write using R, and looks like the following: ex() %&gt;% With this in mind, let us learn about the first set of submission correctness tests we can write. "],
["pre-submission-correctness-test.html", "Chapter 1 Pre Submission Correctness Test 1.1 Pre-Exercise Code 1.2 Sample Code 1.3 Hint 1.4 Example 1.5 More Resources", " Chapter 1 Pre Submission Correctness Test Chapter description Before we can begin writing a submission correctness test, we first need to create and develop the other elements of a DataCamp light exercise. This chapter serves as a very brief introduction to the other elements of a DataCamp light exercise, as well as the standard notation utilized in the regression book {link here?}. 1.1 Pre-Exercise Code In this section, you will learn: -The code indicating we are writing the pre-exercise code -The importance and usefulness of the pre-exercise code The pre-exercise code is a set of code that gives you the ability to run code “behind the scenes”. Typically, these are used to create/assign data to variable names used by the learner. This could be as simple as assigning x to be 23, or as complex as loading in a dataframe, removing/adding columns, renaming columns, and then renaming the whole dataframe. To add pre-exercise code to your exercise, you will first have to create a new section code in an R markdown document, which will create something that looks like the following: Now, we need to modify a few arguments inside “{r}”. Specifically we need to modify the following: “ex”, “type”, and “tut”. This will look something like the following: For a given set of pre-exercise code, hint, soluton, sct, and sample code, all of the “ex” should be the same. This way DataCamp Lite knows to combine them into a single exercise, as opposed to making each one belong to its own exercise. ## Solution In this section, you will learn: -The code indicating we are writing the solution code -The importance and usefulness of the solution code The soltuion code quite simply the “perfect” solution to the problem asked. Ideally, this is done in as few lines as possible, but as many lines as needed. Basially you want it to be a concise answer, but not too concise where it becomes hard to understand or write an SCT for. This gets written like normal R code you would write to solve the problem. Once again, this will require making a new r chunk in markdown, and modifying the “ex”, “type”, and “tut” arguments. This will looking something like the following for the solution code: 1.2 Sample Code In this section, you will learn: -The code indicating we are writing the sample code -The importance and usefulness of the sample code The sample code acts as a framework for the code the learner should use to solve the code. It can be as simple as having multiple comments telling the learner what to do. This could be something like: #Find the mean of `miles per gallon` using the dataframe `mtcars`, and assign the value to `mean.mpg` On the other hand, you could also put your solution code as your sample code, and then remove a few arguments to allow a learner to understand better how certain functions work, and what arguments they need to plug in. For example, if the question asked a learner to generate 4 random numbers from the exponential distribution with mean 20, you could give them the following code: random.numbers=rexp(n=___,rate=____) Then, all the learner has to do is plug in n=4 and rate=1/20 in order to get the correct answer. Once again, this will require making a new r chunk in markdown, and modifying the “ex”, “type”, and “tut” arguments. This will looking something like the following for the sample code: 1.3 Hint In this section, you will learn: -The code indicating we are writing the hint -The importance and usefulness of using hint The hint, very simply, creates a button that the learner can press to recieve a pre-written hint about how to go about solving the problem. For example, if the question called for the learner to round a value x to 3 digits, the hint could say something like: &quot;to round a number, you can use `round(x,digits), where x is the number you want to round, and digits is how many digits you would like.&quot; Once again, this will require making a new r chunk in markdown, and modifying the “ex”, “type”, and “tut” arguments. This will looking something like the following for the solution code: 1.4 Example Below is the code used in the first exercise for the linear regression book. First you will see a picture of the code, and then you will see what the code actually looks like. The only other thing that was added was the assignment text and instructions which are both just standard text typed before the hint chunk. 1.4.1 Exercise. Fitting Galton’s height data Assignment Text The Galton data has already been read into a dataframe called heights. These data include the heights of 928 adult children child_ht, together with an index of their parents’ height parent_ht. The video explored the distribution of the parents’ height; in this assignment, we investigate the distribution of the heights of the adult children. Instructions Define the height of an adult child as a global variable Use the function mean() to calculate the mean and the function sd() to calculate the standard deviation Use the normal approximation and the function pnorm() determine the probability that an adult child’s height is less than 72 inches eyJsYW5ndWFnZSI6InIiLCJwcmVfZXhlcmNpc2VfY29kZSI6IiNoZWlnaHRzIDwtIHJlYWQuY3N2KFwiQ1NWRGF0YVxcXFxnYWx0b25faGVpZ2h0LmNzdlwiLGhlYWRlciA9IFRSVUUpXG5oZWlnaHRzIDwtIHJlYWQuY3N2KFwiaHR0cHM6Ly9hc3NldHMuZGF0YWNhbXAuY29tL3Byb2R1Y3Rpb24vcmVwb3NpdG9yaWVzLzI2MTAvZGF0YXNldHMvYzg1ZWRlNmMyMDVkMjIwNDllNzY2YmQwODk1NmIyMjVjNTc2MjU1Yi9nYWx0b25faGVpZ2h0LmNzdlwiLCBoZWFkZXIgPSBUUlVFKSIsInNhbXBsZSI6IiNEZWZpbmUgdGhlIGdsb2JhbCB2YXJpYWJsZVxuaHRfY2hpbGQgPC0gX19fXG5cbiNDYWxjdWxhdGUgdGhlIG1lYW4gaGVpZ2h0XG5tY2hpbGQgPC0gX19fXG5tY2hpbGRcblxuI0NhbGN1bGF0ZSB0aGUgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIGhlaWdodHNcbnNkY2hpbGQgPC0gX19fXG5zZGNoaWxkXG5cbiNEZXRlcm1pbmUgdGhlIHByb2JhYmlsaXR5IHRoYXQgdGhlIGhlaWdodCBpcyBsZXNzIHRoYW4gNzJcbnByPV9fXyg3MiwgbWVhbj1tY2hpbGQsIHNkPXNkY2hpbGQpIiwic29sdXRpb24iOiJodF9jaGlsZCA8LSBoZWlnaHRzJGNoaWxkX2h0XG5tY2hpbGQgPC0gbWVhbihodF9jaGlsZClcbnNkY2hpbGQgPC0gc2QoaHRfY2hpbGQpXG5wcj1wbm9ybSg3MiwgbWVhbiA9IG1jaGlsZCwgc2QgPSBzZGNoaWxkKSIsInNjdCI6ImV4KCkgJT4lIGNoZWNrX29iamVjdChcImh0X2NoaWxkXCIsdW5kZWZpbmVkX21zZz1cIk1ha2Ugc3VyZSB5b3UgYXNzaWduIHRoZSBjaGlsZHJlbidzIGhpZ2h0IHRvIGh0X2NoaWxkXCIpICU+JSBjaGVja19lcXVhbChpbmNvcnJlY3RfbXNnPVwiUmVtZW1iZXIgdGhhdCBpbiBvcmRlciB0byBjYWxsIGEgc3BlY2lmaWMgY29sdW1uIGZyb20gYSBkYXRhZnJhbWUsIHVzZSB0aGUgJCBvcGVyYXRvclwiKVxuZXgoKSAlPiUgY2hlY2tfb2JqZWN0KFwibWNoaWxkXCIsdW5kZWZpbmVkX21zZz1cIk1ha2Ugc3VyZSB0byBhc3NpZ24gdGhlIG1lYW4gb2YgdGhlIGNoaWxkcmVuJ3MgaGVpZ2h0cyB0byBgbWNoaWxkYC5cIikgICU+JSBjaGVja19lcXVhbCgpXG5leCgpICU+JSBjaGVja19vYmplY3QoXCJzZGNoaWxkXCIsdW5kZWZpbmVkX21zZz1cIk1ha2Ugc3VyZSB0byBhc3NpZ24gdGhlIHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgY2hpbGRyZW4ncyBoZWlnaHRzIHRvIGBzZGNoaWxkYC5cIikgJT4lIGNoZWNrX2VxdWFsKClcbmV4KCkgJT4lIGNoZWNrX29iamVjdChcInByXCIsdW5kZWZpbmVkX21zZz1cIk1ha2Ugc3VyZSB0byBhc3NpZ24gdGhlIHByb2JhYmlsaXR5IG9mIGEgY2hpbGQgYmVpbmcgbGVzcyB0aGFuIDcyIGluY2hlcyB0byBgcHJgLlwiKSAlPiUgY2hlY2tfZXF1YWwoKVxuc3VjY2Vzc19tc2coXCJFeGNlbGxlbnQhIFdpdGggdGhpcyBwcm9jZWR1cmUsIHlvdSBjYW4gbm93IGNhbGN1bGF0ZSBwcm9iYWJpbGl0aWVzIGZvciBhbnkgZGlzdHJpYnV0aW9uIHVzaW5nIGEgbm9ybWFsIGN1cnZlIGFwcHJveGltYXRpb24uXCIpIiwiaGludCI6IlJlbWVtYmVyIHRoYXQgd2UgY2FuIHJlZmVyZW5jZSBhIHZhcmlhYmxlLCBzYXkgPGNvZGU+dmFyPC9jb2RlPiwgZnJvbSBhIGRhdGEgc2V0IHN1Y2ggYXMgPGNvZGU+aGVpZ2h0czwvY29kZT4sIGFzIDxjb2RlPmhlaWdodHMkdmFyPC9jb2RlPi4ifQ== 1.5 More Resources If you are looking for more information, try looking at the folliwng wedpage[https://datacamp.github.io/tutorial/] "],
["checking-objects.html", "Chapter 2 Checking Objects 2.1 Checking a vector 2.2 Checking a Dataframe 2.3 review", " Chapter 2 Checking Objects Chapter description This chapter serves as in introduction to the most basic and useful submission correctness test that can be utilized in both DataCamp and DataCamp light, how to check objects in R. It begins with checking the existence of vectors in R, moves into making sure that the contents of the vector are correct, and ends with checking the existence of dataframes, as well as specific columns inside of a dataframe. 2.1 Checking a vector In this section, you will learn how to: Check that a vector exists in R Check to see if the contents of the vector match the contents found in the solution. 2.1.1 Checking an object’s existence One of the most useful tools that can be utilized when creating submission correctness tests. Say for example, that the question asked a learner to assign the value of 23 to the variable x. The correct answer would look something like the following: x = 23 The first step is to check and see whether or not the learner was able to define a variable x. This can be done with the check_object() function in R. A SCT that property identifies whether or not a learner was able to create an object named x can be seen below: ex() %&gt;% check_object(&quot;x&quot;) If the learner has assigned any value or string to a variable named x, the SCT will come back as passed, and will assume everything is correct. The check_object() function will work for any object that exists in R, such as singular numbers, vectors, character strings, matrices, and lists. This implies that all of the following as “correct” possible answers while using the previously mentioned SCT: x = 23 x = c(19,4,6) x = &quot;oranges&quot; x = matrix(NA,nrow=7,ncol=3) Since this can not all possibly be correct at the same time, it is also important to write a SCT that checks to insure the content of the object is also correct. 2.1.2 Check an object’s correctness Now that we are able to check and see whether or not an object has been defined in R, it becomes important to check to see whether or not the content of that object matches what is found in the solution. looking back to our simple example we have: x = 23 We are aware that we can check if x exists or not in the R environment using Check_object(). Following that, we are able to utilize check_equal() as the next step in order to see if the content of x matches what is found in the solution inventor. One example of an SCT what would property check the existence and correctness of x would be as follows: ex() %&gt;% check_object(&quot;x&quot;) %&gt;% check_equal() This SCT first checks to see whether or not an object named x exists in the R environment. If x does not exist, it will give a general error saying that the object x has yet to be defined. If x does exist, then it will check and see whether or not the contents of the learners assigned variable match those found in the solution. Now only the top line works, while the rest fail due to various reasons: #code that would pass x = 23 #code that fails because x is not defined y = 3.14 y = 23 #code that fails because x is not correct x = c(19,4,6) x = &quot;oranges&quot; x = matrix(NA,nrow=7,ncol=3) 2.2 Checking a Dataframe In this section, you will learn how to: Check that a dataframe exists in R Check to see that specific columns have been defined within a dataframe 2.2.1 Checking a dataframe’s existence and correctness Let us complicate our example a little bit, and move from a simple vector to a dataframe initially containing two columns, x1 and x2 into a dataframe named test.data as follows: x1=seq(1,10,1) x2=rep(2,10) test.data=data.frame(x1,x2) Using check_object() we can check and see whether or not the dataframe exists, just like any other object in R. One SCT for testing this using our example is as follows: ex() %&gt;% check_object(&quot;test.data&quot;) in addition to that, we may also use check_equal() to insure that the learner’s solution, and the official solution are a perfect match. This would look something like the following: ex() %&gt;% check_obect(&quot;test.data&quot;) %&gt;% check_equal() 2.2.2 Checking columns While it may be useful to check that the entirety of the learner’s dataframe perfectly matches yours, there may be situations where the learner decides to take an extra step in getting to the desired solution. Take the following as an example: #Pre Exercise Code O=c(5,4,8,2,9,3,5) E=c(4,6,8,4,8,1,7) data.chisq=data.frame(O,E) #Solution Code data.chisq$chisq=((data.chisq$O-data.chisq$E)^2)/data.chisq$E #Learner&#39;s Code data.chisq$O.E=data.chisq$O-data.chisq$E data.chisq$sq=data.chisq$O.E^2 data.chisq$chisq=data.chisq$sq/data.chisq$E As you can tell, the learner created a few extra columns that were used to calculate the end result. If we were to simply use check_equal() immediately after our check_object(), the result would say that the learner’s answer is not correct, which is not the result we want. We can get around this by checking to see whether or not a specific column exists inside of a dataframe, and then checking to see if its contents are correct. To check the existence of a column inside of a dataframe, we can use the check_column() function after our check_object() function as follows: ex() %&gt;% check_object(&quot;data.chisq&quot;) %&gt;% check_column(., &quot;chisq&quot;) Furthermore, we can check and insure that the contents of data.chisq$chisq are correct by adding the check_equal() function after the check_column() function as such: ex() %&gt;% check_object(&quot;data.chisq&quot;) %&gt;% check_column(., &quot;chisq&quot;) %&gt;% check_equal() 2.3 review By now, you should be able to: -check an object’s existence -Check to see if an object has been correctly defined -check to see if specific columns in a dataframe have been defined correctly "],
["checking-functions.html", "Chapter 3 Checking Functions 3.1 Checking function calls 3.2 Calling Functions Correctly 3.3 review", " Chapter 3 Checking Functions Chapter Description This chapter introduces the concept of checking whether or not specific functions have been called. These can be used to not only check whether or not a given function has been called, but also can be used to check specific arguments of the function to make sure they have been specified and that the argument is the same as that given in the solution. At the conclusion of this chapter, we focus on checking the output of a function as a way of checking if a function has been called correctly. 3.1 Checking function calls In this section, you will learn how to: -Check whether or not a specific function was called In addition to being able to check and see whether or not an object exists within R, it can also be helpful to check and see if specific functions were called. The easiest way to do this is by using the check_function() function. For example, lets say you asked the learner to find the standard deviation of a data set that was given to them. The solution might look something like the flowing: sd(mtcars$mpg) Since we only wanted to know what the standard deviation was, and since we did not ask the learner to assign this value to a variable, we can not use check_object(). We can, however, use check_function() to see if they called the function sd. This would look something along the lines of this: ex() %&gt;% check_function(&quot;sd&quot;) This will check and see whether or not the code submitted by the learner contained a call of the function sd() The problem with simply using check_function() is that there is no check to see if we found the standard deviation of the correct thing or not, so all of the following would pass the SCT above. sd(mtcars$mpg) sd(1) sd(mtcars$disp) sd(c(1,2,3)) 3.2 Calling Functions Correctly When it comes to creating SCTs that also check to see if the right answer was reached using the given function, you have two options. You can either create an SCT that specifies certain arguments that must match, or you can create an SCT that checks to see if the output is the same. 3.2.1 Argument Approach In this section, you will learn how to: -Check the arguments of a function to see if they were called -Check the called arguments of a function and see if they were correct One way to ensure that the function gives out the correct result is to specify that all of the arguments utilized in the function are correct. The R code to write this SCT utilizes the check_arg() function in order to check a specific argument in a function. Referring back to our standard deviation example, we had: sd(mtcars$mpg) If we were to include the check_arg() function in addition to our check_function() function, we would have the following SCT that figures out if the learner found the standard deviation of miles per gallon in the dataframe mtcars. In addition to this, we can add the check_equal() to the end of our check_arg() call to make sure that the argument that the learner specified in the function is the exact same as the one specified in the solution. ex() %&gt;% check_function(&quot;sd&quot;) %&gt;% check_arg(., &quot;x&quot;) %&gt;% check_equal() The upside to utilizing this method, is that you get to write unique error messages for each argument that was not specified correctly, which will help the learner better understand where they went wrong, and why their solution was not correct. If you are having difficulties finding out the correct name of the argument you want to specify in a SCT, type ? followed by the function name in order to see what arguments are normally used by a function. 3.2.2 Output Approach In this section, you will learn how to: -Check function calls by looking at the result of the function the other approach that can be utilized is simply checking the result, and making sure that the output from the function is the same as the output from that same function in the solution. This can be done by using the check_result() function. For example, lets say that the exercises wanted the learner to run summary() on the full data set mtcars, which would appear as the following: summary(mtcars) The corresponding SCT would take the check_function() call to see if summary was called, would lead into a check_result to specify that we are interested in looking at the result from the function, as opposed to the arguments contained in the function, and the check_equal() would make sure that the result from the learner’s submitted code is equal to the result from the solution code. The full statement would look like this: ex() %&gt;% check_function(&quot;summary&quot;) %&gt;% check_result() %&gt;% check_equal() The upside to utilizing this method is that it does not care exactly how the learner got to the correct answer, only that they utilized the correct function, and that the function’s output was equal to what the solution had. The downside being that for complex functions, it may be harder to track down a small mistake if and when one is made. 3.3 review By now, you should be able to: -Check to see if a function was called -Check to see if the arguments of a function were correctly specified -Check to see if the result of a function is equal to the solution "],
["extras.html", "Chapter 4 Extras 4.1 Checking Multiple Conditions 4.2 Multiple Function Calls 4.3 Messages 4.4 review", " Chapter 4 Extras Chapter Description This chapter introduces a variety of special conditions and unique functions that can be used to create more accurate and useful submission correctness tests. In addition to this, we also mention arguments of check functions that can be used to write custom error or success messages to your submission correctness tests. 4.1 Checking Multiple Conditions In this section, you will learn how to: -Check multiple arguments for a given function -check multiple columns for a given dataframe 4.1.1 Multiple arguments While being able to check if a single argument is correct in a given function is nice, there are a wide variety of functions were a single argument is not sufficient in order to guarantee correctness of the learner’s submission. Some examples of functions like these are lm(), plot(), and round() as well as many others. Let us say you wanted the learner to run a simple linear regression on a data set. The solution may look something like the following: lm(hp~mpg, data=mtcars) In this problem, we would want to be able to check that both the formula and the data arguments are specified correctly in the learner’s submission. In order for us to do this, we can make use of brackets {} in order to set up multiple checks for the same function. an example of an SCT that would properly check this would be the following: ex() %&gt;% check_function(&quot;lm&quot;) %&gt;% { check_arg(., &quot;formula&quot;) %&gt;% check_equal() check_arg(., &quot;data&quot;) %&gt;% check_equal() } As a note: the lm() function is a very adaptable function, and there are multiple ways to run the regression and receive the same output, such as the following: lm(mtcars$hp~mtcars$mpg) This means that at times, checking multiple arguments may not be the best fit for the SCT, and it may be better to simply check the result using check_result() 4.1.2 Multiple columns Using brackets to check multiple things per call of check_------() is not just unique to functions, and can be applied to nearly all of the check functions that can be used. Another typical use of checking multiple items looks at multiple columns within a dataframe. Lets say you have the following pre-exercise and solution code: #pre-exercise mpg=mtcars$mpg hp=mtcars$hp test.data=data.frame(mpg,hp) #solution code test.data$L.hp=log(hp) test.data$SQRT.hp=sqrt(hp) While it is possible to simply check and see if the entire dataframe is correct using a SCT as follows: ex() %&gt;% check_object(&quot;test.data&quot;) %&gt;% check_equal() The SCT does not give you the ability to help learner’s track down exactly where they went wrong in working their way to the solution. A more accurate and helpful approach would be to make use of brackets in the following way: ex() %&gt;% check_object(&quot;test.data&quot;) %&gt;% { check_column(., &quot;L.hp&quot;) %&gt;% check_equal() check_column(., &quot;SQRT.hp&quot;) %&gt;% check_equal() } This gives learners more specific feedback if and when they make a mistake while trying to reach the correct answer. As an important note, there are many instances in the SCT were a check_arg() or a check_column() has a . as the first argument followed by a , and then the name of the argument/column that we would like to check. This . is a very important argument for the check family of functions, as it allows the function to search the entirety of the function/dataframe for the listed argument/column, as opposed to only being able to check in a few pre-defined places. If you find that an SCT is not preforming how you believe it should, try adding the ., into your check functions to see if that alleviates the problem. 4.2 Multiple Function Calls In this section, you will learn how to: -Check if a function is called multiple times -check if each function call gives the correct output Normally, a problem will only require that a function be called one time at most. Thing such as standard deviations, means, summarys, and plots are done once to get an overview of the data before any real analysis or manipulation of the data starts. However, there are situations where one must make multiple calls of these functions. One example could be if you wanted to have side-by-side graphs, showing the relationship between two things. The pre-exercise and solution code could look like the following: #Pre-exercise mpg=mtcars$mpg hp=mtcars$hp Lhp=log(mtcars$hp) par(mfrow=c(1,2)) #Solution code plot(x=mpg, y=hp, pch=19, col=&quot;red&quot;, main=&quot;Miles per gallon vs Horsepower&quot;) plot(x=mpg, y=Lhp, pch=19, col=&quot;blue&quot;, main=&quot;Miles per gallon vs log Horsepower&quot;) The standard intuition would be to have 2 SCTs, one to check each call of the function plot() as follows. ex() %&gt;% check_function(&quot;plot&quot;) %&gt;% { check_arg(., &quot;x&quot;) %&gt;% check_equal() check_arg(., &quot;y&quot;) %&gt;% check_equal() } ex() %&gt;% check_function(&quot;plot&quot;) %&gt;% { check_arg(., &quot;x&quot;) %&gt;% check_equal() check_Arg(., &quot;y&quot;) %&gt;% check_equal() } While this may appear to make sense, as you check for plot twice, both calls of check_function(&quot;plot&quot;) will find the first instance of plot, and check that one only. This means even if you were to nest extra check_arg() such as the title or the color, both of the SCTs would focus on the first call of plot() to get around this, we can use an argument inside of check_function() named index. By setting index equal to an integer corresponding with which call of the function you would like the SCT to check, you can now check both calls of plot() and insure they were used correctly. The correct SCT for this problem could look like: ex() %&gt;% check_function(&quot;plot&quot;, index=1) %&gt;% { check_arg(., &quot;x&quot;) %&gt;% check_equal() check_arg(., &quot;y&quot;) %&gt;% check_equal() } ex() %&gt;% check_function(&quot;plot&quot;, index=2) %&gt;% { check_arg(., &quot;x&quot;) %&gt;% check_equal() check_arg(., &quot;y&quot;) %&gt;% check_equal() } Now our SCT is set so that our first call of check_function() looks specifically at the first call of plot() and our second call of check_function() looks only at the second call of plot() 4.3 Messages In this section, you will learn how to: -Write custom error messages for each function in the check family. -Include a success message at the end of a SCT 4.3.1 Error Messages For each and every check function that has been presented in this guide, there is also a matching error message that lets you input a custom message that is displayed if that particular check function is what causes the SCT to fail. Below is a guide showing each of the functions with its matching error message: print(Error.Messages,row.names=FALSE) ## Function Message ## check_object undefined_msg ## check_column col_missing_msg ## check_function not_called_msg ## check_arg arg_not_specified_msg ## check_equal incorrect_msg The check_result() function does not need to have its own error message, because check result does not actually check anything, it only passes along to the check_equal() that it should be making sure that the solutions are equal. For example, lets say the pre-exercise and solution code looked something like the following: #pre-exercise x=4.68451 #solution round(x,4) A working SCT with error messages could look like this: ex() %&gt;% check_function(&quot;round&quot;, not_called_msg=&quot;Use the `round()` function to round x.&quot;) %&gt;% { check_arg(., &quot;x&quot;, arg_not_specified_msg=&quot;Make sure to round the value found in x&quot;) %&gt;% check_equal(incorrect_msg=&quot;Make sure x = 4.68451&quot;) check_arg(., &quot;digits&quot;,arg_not_specified_msg=&quot;Make sure to specify we want to round x to a specific number of digits&quot;) %&gt;% check_equal(incorrect_msg=&quot;We would like to round x to 4 digits&quot;) } 4.3.2 Success Messages While it is always nice to know what you’ve gotten wrong, it is also nice to receive a positive message whenever you get the problem correct, this can be done with the success_msg() function. The success_msg() goes on its own line, and does not have the typical ex() %&gt;% that the other functions start with. For a very simple example lets say we have the following solution code: x=4 A SCT with a nice success_msg would look like the following: ex() %&gt;% check_object(&quot;x&quot;) %&gt;% check_equal() success_msg(&quot;Excellent! you were able to asssign a value of 4 to the variable x.&quot;) 4.4 review By now, you should be able to: -Check for multiple function calls -Check for multiple arguments/columns in a single SCT -Write error and success messages "]
]
